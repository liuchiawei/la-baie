# Vercel React 最佳實踐 - 中文摘要

## 概述

Vercel 工程團隊維護的 React 和 Next.js 性能優化指南，包含 57 個規則，分為 8 個優先級類別。

---

## 1. 消除瀑布流 (CRITICAL - 關鍵)

### 1.1 延遲 await 直到需要時

- 將 `await` 移到實際使用的分支中，避免阻塞不需要的代碼路徑

### 1.2 基於依賴的並行化

- 使用 `better-all` 或手動 Promise 鏈來最大化並行執行
- 讓有部分依賴的操作也能並行運行

### 1.3 防止 API 路由中的瀑布鏈

- 在 API 路由和 Server Actions 中，立即啟動獨立操作，即使還不需要 await

### 1.4 使用 Promise.all() 處理獨立操作

- 當異步操作沒有相互依賴時，使用 `Promise.all()` 並發執行

### 1.5 策略性 Suspense 邊界

- 使用 Suspense 邊界來更快顯示包裝 UI，同時數據在後台加載

---

## 2. 打包大小優化 (CRITICAL - 關鍵)

### 2.1 避免桶文件導入

- 直接從源文件導入，避免通過桶文件（barrel files）導入
- 可節省 200-800ms 導入時間，加快開發和生產冷啟動

### 2.2 條件模塊加載

- 只在功能激活時加載大型數據或模塊

### 2.3 延遲非關鍵第三方庫

- 在 hydration 後加載分析、日誌和錯誤追蹤庫

### 2.4 大型組件的動態導入

- 使用 `next/dynamic` 懶加載初始渲染不需要的大型組件

### 2.5 基於用戶意圖的預加載

- 在懸停/聚焦時預加載重型 bundle，減少感知延遲

---

## 3. 服務端性能 (HIGH - 高)

### 3.1 像 API 路由一樣驗證 Server Actions

- 在每個 Server Action 內部驗證身份和授權，不要僅依賴中間件

### 3.2 避免 RSC Props 中的重複序列化

- 在客戶端進行轉換（`.toSorted()`, `.filter()`, `.map()`），而不是在服務端

### 3.3 跨請求 LRU 緩存

- 使用 LRU 緩存來共享跨順序請求的數據

### 3.4 最小化 RSC 邊界的序列化

- 只傳遞客戶端實際使用的字段，減少數據傳輸大小

### 3.5 通過組件組合實現並行數據獲取

- 重構組件結構，讓數據獲取並行執行，消除服務端瀑布流

### 3.6 使用 React.cache() 進行請求內去重

- 使用 `React.cache()` 在單個請求內去重服務端操作

### 3.7 使用 after() 處理非阻塞操作

- 使用 Next.js 的 `after()` 在響應發送後執行日誌、分析等操作

---

## 4. 客戶端數據獲取 (MEDIUM-HIGH - 中高)

### 4.1 去重全局事件監聽器

- 使用 `useSWRSubscription()` 在多個組件實例間共享全局事件監聽器

### 4.2 使用被動事件監聽器提升滾動性能

- 為觸摸和滾輪事件監聽器添加 `{ passive: true }`，啟用立即滾動

### 4.3 使用 SWR 自動去重

- 使用 SWR 實現請求去重、緩存和跨組件實例的重新驗證

### 4.4 版本化和最小化 localStorage 數據

- 為鍵添加版本前綴，只存儲需要的字段，防止模式衝突

---

## 5. 重新渲染優化 (MEDIUM - 中)

### 5.1 在渲染期間計算派生狀態

- 如果值可以從當前 props/state 計算，在渲染時派生，不要存儲在 state 中

### 5.2 將狀態讀取延遲到使用點

- 如果只在回調中使用動態狀態，不要訂閱它

### 5.3 不要為簡單表達式使用 useMemo

- 當表達式簡單且結果為原始類型時，不要使用 `useMemo`

### 5.4 提取默認非原始參數值到常量

- 將 memoized 組件的默認非原始參數值提取為常量，恢復記憶化

### 5.5 提取到記憶化組件

- 將昂貴的工作提取到記憶化組件中，實現早期返回

### 5.6 縮小 Effect 依賴

- 指定原始依賴而不是對象，最小化 effect 重新運行

### 5.7 將交互邏輯放在事件處理器中

- 如果副作用由特定用戶操作觸發，在事件處理器中運行，不要建模為 state + effect

### 5.8 訂閱派生狀態

- 訂閱派生的布爾狀態而不是連續值，減少重新渲染頻率

### 5.9 使用函數式 setState 更新

- 基於當前狀態值更新時，使用函數式更新形式，防止過時閉包

### 5.10 使用懶惰狀態初始化

- 為昂貴的初始值向 `useState` 傳遞函數，避免每次渲染都運行

### 5.11 使用 Transitions 處理非緊急更新

- 將頻繁的非緊急狀態更新標記為 transitions，保持 UI 響應性

### 5.12 使用 useRef 處理瞬態值

- 當值頻繁變化且不想每次更新都重新渲染時，使用 `useRef` 而不是 `useState`

---

## 6. 渲染性能 (MEDIUM - 中)

### 6.1 動畫 SVG 包裝器而非 SVG 元素

- 將 SVG 包裝在 `<div>` 中並動畫包裝器，啟用硬件加速

### 6.2 長列表使用 CSS content-visibility

- 應用 `content-visibility: auto` 延遲屏幕外渲染

### 6.3 提升靜態 JSX 元素

- 將靜態 JSX 提取到組件外部，避免重新創建

### 6.4 優化 SVG 精度

- 減少 SVG 坐標精度以減小文件大小

### 6.5 防止水合不匹配且無閃爍

- 使用同步腳本在 React 水合前更新 DOM，避免視覺閃爍

### 6.6 抑制預期的水合不匹配

- 對於服務端和客戶端有意不同的值，使用 `suppressHydrationWarning` 抑制警告

### 6.7 使用 Activity 組件處理顯示/隱藏

- 使用 React 的 `<Activity>` 保留頻繁切換可見性的昂貴組件的狀態/DOM

### 6.8 使用顯式條件渲染

- 當條件可能為 `0`、`NaN` 或其他假值時，使用三元運算符而不是 `&&`

### 6.9 使用 useTransition 而非手動加載狀態

- 使用 `useTransition` 提供內置的 `isPending` 狀態，自動管理 transitions

---

## 7. JavaScript 性能 (LOW-MEDIUM - 低中)

### 7.1 避免布局抖動

- 避免在樣式寫入之間交錯布局讀取，批量處理樣式更改

### 7.2 為重複查找構建索引 Map

- 多次使用相同鍵的 `.find()` 調用應使用 Map

### 7.3 在循環中緩存屬性訪問

- 在熱路徑中緩存對象屬性查找

### 7.4 緩存重複函數調用

- 使用模塊級 Map 緩存函數結果，當同一函數重複調用相同輸入時

### 7.5 緩存存儲 API 調用

- 在內存中緩存 `localStorage`、`sessionStorage` 和 `document.cookie` 的讀取

### 7.6 合併多個數組迭代

- 將多個 `.filter()` 或 `.map()` 調用合併為一個循環

### 7.7 數組比較的早期長度檢查

- 在進行昂貴操作（排序、深度相等、序列化）前先檢查長度

### 7.8 函數早期返回

- 當結果確定時提前返回，跳過不必要的處理

### 7.9 提升 RegExp 創建

- 不要在渲染中創建 RegExp，提升到模塊作用域或使用 `useMemo()` 記憶化

### 7.10 使用循環而非排序來找最小/最大值

- 只找最小或最大元素時使用單次遍歷，不要排序整個數組

### 7.11 使用 Set/Map 進行 O(1) 查找

- 將數組轉換為 Set/Map 進行重複的成員檢查

### 7.12 使用 toSorted() 而非 sort() 實現不可變性

- 使用 `.toSorted()` 創建新的排序數組，不改變原數組，防止 React 狀態突變錯誤

---

## 8. 高級模式 (LOW - 低)

### 8.1 初始化應用一次，而非每次掛載

- 不要將必須在每次應用加載時運行一次的應用級初始化放在組件的 `useEffect([])` 中

### 8.2 在 Refs 中存儲事件處理器

- 當回調用於不應在回調變化時重新訂閱的 effects 時，將回調存儲在 refs 中

### 8.3 使用 useEffectEvent 實現穩定的回調 Refs

- 在不將它們添加到依賴數組的情況下訪問回調中的最新值，防止 effect 重新運行同時避免過時閉包

---

## 優先級總結

| 優先級 | 類別            | 影響        | 規則數量 |
| ------ | --------------- | ----------- | -------- |
| 1      | 消除瀑布流      | CRITICAL    | 5        |
| 2      | 打包大小優化    | CRITICAL    | 5        |
| 3      | 服務端性能      | HIGH        | 7        |
| 4      | 客戶端數據獲取  | MEDIUM-HIGH | 4        |
| 5      | 重新渲染優化    | MEDIUM      | 12       |
| 6      | 渲染性能        | MEDIUM      | 9        |
| 7      | JavaScript 性能 | LOW-MEDIUM  | 12       |
| 8      | 高級模式        | LOW         | 3        |

**總計：57 個規則**

---

## 使用建議

- **編寫新組件時**：參考這些指南確保最佳性能模式
- **代碼審查時**：檢查是否存在性能問題
- **重構代碼時**：優先處理 CRITICAL 和 HIGH 優先級的問題
- **性能優化時**：從消除瀑布流和減少打包大小開始
